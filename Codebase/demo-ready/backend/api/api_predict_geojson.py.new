"""
API endpoint for predicting sea-ice extent and converting predictions to GeoJSON point clouds.

This module uses a pretrained RBF kernel model to predict sea ice presence and returns
the predictions as a GeoJSON feature collection. Results can be cached in-memory for
repeated requests of the same date and parameters.
"""
from __future__ import annotations

from datetime import datetime
from functools import lru_cache
from typing import Dict, Tuple
from pathlib import Path
import os

import geopandas as gpd
import numpy as np
import rasterio
import torch
from fastapi import FastAPI, Query
from fastapi.responses import JSONResponse
from rasterio.transform import xy as transform_xy
from shapely.geometry import Point
import json


class PredictionError(RuntimeError):
    """Raised when model prediction or conversion to GeoJSON fails."""


# ---------------------- Model Configuration ----------------------
MODEL_ROOT = Path(
    os.environ.get(
        "ICE_MODEL_DIR", 
        Path(__file__).resolve().parent.parent / "datasets" / "trained_data"
    )
).resolve()
MODEL_PATH = MODEL_ROOT / "rbf_model_2015_2025_spatiotemporal.npz"
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"

print(f"Using device: {DEVICE}")
print(f"Loading model from: {MODEL_PATH}")

# Load model data
try:
    if not MODEL_PATH.exists():
        raise PredictionError(f"Model file not found at {MODEL_PATH}")
    data = np.load(str(MODEL_PATH), allow_pickle=True)
    weights = torch.from_numpy(data["weights"]).to(DEVICE).float()   # (N_valid, T)
    valid_mask = data["valid_mask"].astype(bool)                     # (H, W)
    years = data["years"]
    months = data["months"]
    alpha = float(data["alpha"])
    gamma = float(data["gamma"])
    H, W = int(data["H"]), int(data["W"])

    A, B, C, D, E, F = data["transform"].tolist()
    transform = rasterio.Affine(A, B, C, D, E, F)
    crs = rasterio.crs.CRS.from_string(str(data["crs"]))

    # Precompute temporal features
    year_norm = (years - years.min()) / max(1, (years.max() - years.min()))
    month_sin = np.sin(2 * np.pi * months / 12.0)
    month_cos = np.cos(2 * np.pi * months / 12.0)
    t_features = np.stack([year_norm, month_sin, month_cos], axis=1)
    t = torch.tensor(t_features, dtype=torch.float32, device=DEVICE)
except Exception as exc:
    raise PredictionError(f"Failed to load model from '{MODEL_PATH}': {exc}") from exc


def _rbf_kernel(x1: torch.Tensor, x2: torch.Tensor, gamma: float) -> torch.Tensor:
    """
    Compute the RBF kernel between two sets of temporal features.
    """
    diff = x1[:, None, :] - x2[None, :, :]
    dist2 = torch.sum(diff ** 2, dim=2)
    return torch.exp(-gamma * dist2)


def _get_temporal_features(date: datetime) -> torch.Tensor:
    """
    Convert a datetime into normalized temporal features for the model.
    """
    year_norm_next = (date.year - years.min()) / max(1, (years.max() - years.min()))
    month_sin_next = np.sin(2 * np.pi * date.month / 12.0)
    month_cos_next = np.cos(2 * np.pi * date.month / 12.0)
    return torch.tensor([[year_norm_next, month_sin_next, month_cos_next]], 
                       dtype=torch.float32, device=DEVICE)


def _predict_ice_mask(date: datetime, thresh: float = 0.5) -> Tuple[np.ndarray, np.ndarray]:
    """
    Generate binary ice presence mask for given date using the RBF model.
    """
    t_next = _get_temporal_features(date)
    k_star = _rbf_kernel(t, t_next, gamma)
    preds = (weights @ k_star).squeeze(-1).detach().cpu().numpy()
    preds = np.clip(preds, 0, 1)

    pred_prob = np.zeros((H, W), dtype=np.float32)
    pred_prob[valid_mask] = preds
    ice_mask = (pred_prob >= thresh) & valid_mask
    return ice_mask, pred_prob


def _filter_points(
    ice_mask: np.ndarray,
    pred_prob: np.ndarray,
    radius_km: float
) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    Filter ice pixels based on distance from pole and extract coordinates.
    """
    # Compute distance from pole
    cols, rows = np.meshgrid(np.arange(W), np.arange(H))
    xs = transform.c + cols * transform.a + rows * transform.b
    ys = transform.f + cols * transform.d + rows * transform.e
    dist_km = np.sqrt(xs**2 + ys**2) / 1000.0
    
    # Apply distance filter
    mask = ice_mask & (dist_km > radius_km)
    rows, cols = np.where(mask)
    probs = pred_prob[rows, cols]
    
    # Convert to projected coordinates
    xs_filtered, ys_filtered = transform_xy(transform, rows, cols)
    return xs_filtered, ys_filtered, probs


def _to_feature_collection(
    xs: np.ndarray, 
    ys: np.ndarray,
    probs: np.ndarray,
    date: datetime
) -> Dict:
    """
    Convert coordinate arrays into a GeoJSON feature collection.
    """
    points = [Point(x, y) for x, y in zip(xs, ys)]
    if not points:
        return {"type": "FeatureCollection", "features": []}

    gdf = gpd.GeoDataFrame(
        {
            "date": date.strftime("%Y-%m-%d"),
            "pred_prob": probs.astype(float)
        },
        geometry=points,
        crs=crs
    ).to_crs(epsg=4326)

    return json.loads(gdf.to_json())


# ---------------------- FastAPI App ----------------------
app = FastAPI(title="Sea Ice Predictor API", version="1.0")


@app.get("/")
def root():
    """Health check endpoint."""
    return {"message": "Sea Ice Prediction API is running."}


@lru_cache(maxsize=128)
def _cached_prediction(year: int, month: int, thresh: float, radius_km: float) -> Dict:
    """
    Cached helper function for generating predictions. Cache is keyed by all parameters.
    """
    date = datetime(year, month, 1)
    ice_mask, pred_prob = _predict_ice_mask(date, thresh)
    xs, ys, probs = _filter_points(ice_mask, pred_prob, radius_km)
    geojson = _to_feature_collection(xs, ys, probs, date)
    return geojson


@app.get("/predict")
def predict_sea_ice(
    year: int = Query(..., ge=1979, le=2100, description="Year to predict"),
    month: int = Query(..., ge=1, le=12, description="Month to predict"),
    thresh: float = Query(0.5, ge=0.0, le=1.0, description="Threshold for ice probability"),
    radius_km: float = Query(200.0, ge=0.0, description="Exclude points within this distance (km) from the pole")
) -> JSONResponse:
    """
    Predict sea ice extent for a given year and month.
    Returns a GeoJSON FeatureCollection of predicted ice locations.
    
    Results are cached in-memory keyed by all input parameters.
    """
    try:
        geojson = _cached_prediction(year, month, thresh, radius_km)
        return JSONResponse(content=geojson)
    except Exception as exc:
        raise PredictionError(f"Failed to generate prediction for {year}-{month:02d}: {exc}") from exc